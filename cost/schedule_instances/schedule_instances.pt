name "Schedule instances"
rs_pt_ver 20180301
type "policy"
short_description "A policy that start and stops instances based on a schedule"
long_description "Version 1.0"
severity "medium"
category "Cost"


# parameter "param_schedule" do
#   type "string"
#   label "Schedule Ex: 07-19:M.T.W.Th.F start_hour-end_hour:days_of_week_to_run "
#   default "instance:schedule=Business Hours"
# end

parameter "escalate_to" do
  type "list"
  label "Email addresses"
end

permission "retrieve_resources" do
  label "Retrieve Resources"
  actions   "rs_cm.index","rs_cm.show"
  resources "rs_cm.instances","rs_cm.clouds"
end

permission "retrieve_tags" do
  label "Retrieve Tags"
  actions "rs_cm.by_tag"
  resources "rs_cm.tags"
end

auth "rs", type: "rightscale"

#all clouds
resources "clouds", type: "rs_cm.clouds"

#all instances operational or provisioned
resources "instances_operational", type: "rs_cm.instances" do
  iterate @clouds
  cloud_href href(iter_item)
  filter do
     state "operational"
   end
end
resources "instances_provisioned", type: "rs_cm.instances" do
  iterate @clouds
  cloud_href href(iter_item)
  filter do
     state "provisioned"
   end
end

datasource "instances_provisioned" do
  iterate @instances_provisioned
  field "href",        href(iter_item)
  field "id",          val(iter_item,'resource_uid')
  field "name",        val(iter_item,'name')
  field "state",       val(iter_item,'state')
  field "type",        "instances"
end

datasource "instances_operational" do
  iterate @instances_operational
  field "href",        href(iter_item)
  field "id",          val(iter_item,'resource_uid')
  field "name",        val(iter_item,'name')
  field "state",       val(iter_item,'state')
  field "type",        "instances"
end

datasource "instances" do
  run_script $merge_instances, $instances_operational,$instances_provisioned
end

script "merge_instances", type: "javascript" do
  parameters "instances_operational","instances_provisioned"
  result "instances"
  code <<-EOS
    var instances = []
    for (i = 0; i < instances_operational.length; i++) {
      instances.push(instances_operational[i])
    }
    for (i = 0; i < instances_provisioned.length; i++) {
      instances.push(instances_provisioned[i])
    }
  EOS
end

#all tags on the instances
datasource "ds_instance_tags" do
  request do
    auth $rs
    verb "POST"
    host rs_cm_host
    path "/api/tags/by_tag"
    header "X-Api-Version", "1.5"
    body_field "tags",["instance:schedule=*"]
    body_field "resource_type", "instances"
    body_field "include_tags_with_prefix", "instance:schedule"
  end
end

datasource "clouds" do
  iterate @clouds
  field "href",         href(iter_item)
  field "type",         val(iter_item,'cloud_type')
  field "name",         val(iter_item,'name')
end

datasource "filtered_instances" do
  run_script $js_instance_tags, $instances, $ds_instance_tags, $clouds
end

script "js_instance_tags", type: "javascript" do
  parameters "instances","instance_tags","clouds"
  result "filtered_instances"
  code <<-EOS
  // This is the list of filtered volumes.
  var filtered_instances = [];


  // create a map of clouds with href key to get type and name
  var cloud_map = {}
  for (var i = 0; i < clouds.length; i++) {
      var cloud = clouds[i]
      cloud_map[cloud['href']]={'type': cloud['type'],'name': cloud['name']}
  }

  var instance_map = {}
  for (var i = 0; i < instances.length; i++) {
      var instance = instances[i]
      instance_map[instance['href']]={
        'state': instance['state'],
        'name': instance['name'],
        'id': instance['id']
      }
  }

  // create a map of tags with instance href
  var tags = {};
  for (var i = 0; i < instance_tags.length; i++) {
    rt = instance_tags[i]
    for (var j = 0; j < rt['links'].length; j++) {
      link = rt['links'][j]
      if (link['rel'] == 'resource') {
        tags[link['href']] = rt['tags']
      }
    }
  }

  // This is the map of resource href to its tags.
  for (var i = 0; i < instance_tags.length; i++) {
    it = instance_tags[i]
    for (var j = 0; j < it['links'].length; j++) {
      link = it['links'][j]
      if (link['rel'] == 'resource') {
        // create cloud_href from resource href
        var split = link['href'].split('/')
        var index = link['href'].indexOf('/' + split[4])
        var cloud_href = link['href'].substring(0,index)
        var schedule =[]
        for (var t = 0; t < tags[link['href']].length; t++) {
          tag = tags[link['href']][t]['name']
          tag_key = tag.split("=")[0]
          tag_value = tag.split("=")[1]
          schedule = tag_value
        }
        // create object of instances
        filtered_instances.push(
          {
            id: instance_map[link['href']]['id'],
            name: instance_map[link['href']]['name'],
            state: instance_map[link['href']]['state'],
            href: link['href'],
            cloud_name: cloud_map[cloud_href]['name'],
            cloud_type: cloud_map[cloud_href]['type'],
            schedule: schedule
          }
          )
      }
    }
  }
  EOS
end

escalation "escalate_instances" do
  email $escalate_to
    run "schedule_instances", data
end

policy "instance_scheduler" do
  validate $filtered_instances do
    summary_template "Schedule Instance Policy"
    detail_template <<-EOS
There are {{ len data }} instance(s)

| Name | State | Cloud | Href | schedule |
| ---- | ----- | ----- | ---- | -------- |
{{ range data -}}
| {{ .name }} | {{ .state }} | {{ .cloud_name }} | {{ .href }} | {{ .schedule }}
{{ end -}}
EOS
    escalate $escalate_instances
    check eq(size(data), 0)
  end
end

define schedule_instances($data) do
  call sys_log('schedule_instances','start')
  foreach $item in $data do
    call sys_log('item', to_s($item))

  end
end

define sys_log($subject, $detail) do
  if $$debug
    rs_cm.audit_entries.create(
      notify: "None",
      audit_entry: {
        auditee_href: @@account,
        summary: $subject,
        detail: $detail
      }
    )
  end
end
